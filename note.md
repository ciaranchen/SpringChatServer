## 总结(?)

这份文档是最后由CiaranChen进行维护的，将在这里解释代码中的相关做法并总结一下从这次开发中学到的东西。

### 为什么是WebSocket？

WebSocket是基于HTTP协议的对于长连接的支持。即HTTP协议在一次TCP连接中完成，然而在聊天中会有频繁的连接。Websocket正是解决这个问题，它能达到在一次TCP连接中服务器主动向客户端发送消息，在聊天这个场景中就极为适用。与socket相比：没有可比性。简单来说的话，使用socket的同学需要定义消息传递的格式，而使用WebSocket的话，可以直接使用原有的结构来传递。

使用WebSocket还有一个保持连接的问题，因为TCP连接如果不发送消息的话，会最多在7-15分钟左右被运营商网络移除。解决的方式是心跳包，但是嫌麻烦就没有做了。这个问题对于其他同学也存在，但是我所知并没有关注这个问题的。

### 关于Spring

我非常希望吐槽一下：体验极差。Spring帮我处理了大部分的http的工作，但是它的配置真的太麻烦了，而且更不要说这个过程中有xml和java直接写的配置。同样的对于Mybatis来说也是如此，同时存在xml的配置文件，yml的配置文件还有直接嵌入到spring设置中的文件。而且如果要配置好它，必须要了解其中的一些细节，这让我觉得非常头疼。简直就像是我只想要10%的部分而塞给我了150%。

如果重新来一次，我宁愿使用netty或者别的什么来写一遍。

### 关于`fake_data`

`sqlScripts`文件夹中的两个txt文件分别是：

- 从某一个QQ群中截取的一段聊天记录。当时正在讨论面试成功后庆贺的问题。
- 从QQ与同学私聊中截取的一段聊天记录。当时正在讨论WEB工程组队的问题。

### 关于SQL注入

在查找用户和聊天室中的两个SQL语句实际是有SQL注入问题的。我想应该在业务逻辑中加入对字符串的过滤来解决，但是时间紧迫最后就没有做。

### 关于用户头像上传

使用HTTP协议来上传，这样其实效率并不高（对于小文件来说其实差不了多少）。但是我想这样足够用就行。

### 关于聊天中其他形式的数据

讲道理都可以在WebSocket中进行传递，而只要对聊天的数据做一些封装即可。然而考虑到聊天信息的长度限制，我认为需要第三方的临时文件保存，然后在消息中以url的形式展现。

### 关于登录验证

原本是打算接入通过xxx登录的sdk。但是考虑到前端的交互有点麻烦最后还是放弃了。实际上这个的代码基本完成了一半：可以在util文件夹下，甚至config中的握手控制一段中看到。

### 关于Maven和Gradle

为什么最后选择了gradle？最初参照的是`Spring guides`的[示例项目](https://spring.io/guides/gs/messaging-stomp-websocket/)示例中同时有Maven和Gradle文件，后来发现两个同时维护实在有些太麻烦了。而且Gradle语法比Maven简单，所以最后选择了Gradle文件。

另外得额外提一下Mac下idea的`gradle home`。因为idea自带的gradle是不够的，所以在Mac下需要用`brew`再安装`gradle`；此时的`gradle home`应为`/usr/local/Cellar/gradle/4.5/libexec` (4.5改为`gradle -v`的版本)
